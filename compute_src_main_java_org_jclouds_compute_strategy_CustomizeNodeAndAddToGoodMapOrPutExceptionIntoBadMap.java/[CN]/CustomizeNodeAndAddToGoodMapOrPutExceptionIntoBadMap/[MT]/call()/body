{
  checkState(!tainted,"this object is not designed to be reused: %s",toString());
  tainted=true;
  String originalId=node.getId();
  try {
    if (options.shouldBlockUntilRunning()) {
      if (nodeRunning.apply(node)) {
        node=getNode.getNode(node.getId());
      }
 else {
        NodeMetadata nodeForState=getNode.getNode(node.getId());
        NodeState state=nodeForState == null ? NodeState.TERMINATED : nodeForState.getState();
        throw new IllegalStateException(format("node %s didn't achieve the state running within %d seconds, final state: %s",originalId,timeouts.nodeRunning / 1000,state));
      }
      if (node == null)       throw new IllegalStateException(format("node %s terminated before applying options",originalId));
      if (statement != null) {
        RunScriptOnNode runner=initScriptRunnerFactory.create(node,statement,options,badNodes).call();
        if (runner != null) {
          ExecResponse exec=runner.call();
          customizationResponses.put(node,exec);
        }
      }
      if (options.getPort() > 0) {
        findReachableSocketOnNode(socketTester.seconds(options.getSeconds()),node,options.getPort());
      }
    }
    logger.debug("<< options applied node(%s)",originalId);
    goodNodes.add(node);
  }
 catch (  Exception e) {
    logger.error(e,"<< problem applying options to node(%s): ",originalId,getRootCause(e).getMessage());
    badNodes.put(node,e);
  }
  return null;
}
