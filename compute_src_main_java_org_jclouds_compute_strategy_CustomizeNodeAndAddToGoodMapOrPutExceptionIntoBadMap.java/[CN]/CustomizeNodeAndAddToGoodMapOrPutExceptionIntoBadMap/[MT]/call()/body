{
  checkState(!tainted,"this object is not designed to be reused: %s",toString());
  tainted=true;
  try {
    if (options.shouldBlockUntilRunning()) {
      if (nodeRunning.apply(node)) {
        node=getNode.getNode(node.getId());
      }
 else {
        NodeMetadata nodeForState=getNode.getNode(node.getId());
        NodeState state=nodeForState == null ? NodeState.TERMINATED : nodeForState.getState();
        throw new IllegalStateException(String.format("node didn't achieve the state running on node %s within %d seconds, final state: %s",node.getId(),timeouts.nodeRunning / 1000,state));
      }
      if (statement != null) {
        RunScriptOnNode runner=initScriptRunnerFactory.create(node,statement,options,badNodes).call();
        if (runner != null) {
          ExecResponse exec=runner.call();
          customizationResponses.put(node,exec);
        }
      }
      if (options.getPort() > 0) {
        findReachableSocketOnNode(socketTester.seconds(options.getSeconds()),node,options.getPort());
      }
    }
    logger.debug("<< options applied node(%s)",node.getId());
    goodNodes.add(node);
  }
 catch (  Exception e) {
    logger.error(e,"<< problem applying options to node(%s): ",node.getId(),getRootCause(e).getMessage());
    badNodes.put(node,e);
  }
  return null;
}
