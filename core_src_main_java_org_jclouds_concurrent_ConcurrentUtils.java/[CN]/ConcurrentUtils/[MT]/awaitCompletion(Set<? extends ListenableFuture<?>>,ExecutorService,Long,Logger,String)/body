{
  final int total=responses.size();
  final CountDownLatch doneSignal=new CountDownLatch(total);
  final AtomicInteger complete=new AtomicInteger(0);
  final AtomicInteger errors=new AtomicInteger(0);
  final long start=System.currentTimeMillis();
  for (  final ListenableFuture<?> future : responses) {
    future.addListener(new Runnable(){
      public void run(){
        try {
          future.get();
          complete.incrementAndGet();
        }
 catch (        Exception e) {
          errors.incrementAndGet();
          logException(logger,logPrefix,total,complete.get(),errors.get(),start,e);
        }
        doneSignal.countDown();
      }
    }
,executor);
  }
  try {
    if (maxTime != null)     doneSignal.await(maxTime,TimeUnit.MILLISECONDS);
 else     doneSignal.await();
    if (errors.get() > 0) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      RuntimeException exception=new RuntimeException(message);
      logger.error(exception,message);
      throw exception;
    }
    if (logger.isTraceEnabled()) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      logger.trace(message);
    }
  }
 catch (  InterruptedException e) {
    String message=message(logPrefix,total,complete.get(),errors.get(),start);
    TimeoutException exception=new TimeoutException(message);
    logger.error(exception,message);
    Throwables.propagate(exception);
  }
}
