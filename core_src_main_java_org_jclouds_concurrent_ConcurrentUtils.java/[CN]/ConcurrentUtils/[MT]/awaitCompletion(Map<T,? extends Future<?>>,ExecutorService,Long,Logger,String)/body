{
  if (responses.size() == 0)   return ImmutableMap.of();
  final int total=responses.size();
  final CountDownLatch doneSignal=new CountDownLatch(total);
  final AtomicInteger complete=new AtomicInteger(0);
  final AtomicInteger errors=new AtomicInteger(0);
  final long start=System.currentTimeMillis();
  final Map<T,Exception> errorMap=Maps.newHashMap();
  for (  final java.util.Map.Entry<T,? extends Future<?>> future : responses.entrySet()) {
    makeListenable(future.getValue(),exec).addListener(new Runnable(){
      public void run(){
        try {
          future.getValue().get();
          complete.incrementAndGet();
        }
 catch (        Exception e) {
          errors.incrementAndGet();
          logException(logger,logPrefix,total,complete.get(),errors.get(),start,e);
          errorMap.put(future.getKey(),e);
        }
        doneSignal.countDown();
      }
    }
,exec);
  }
  try {
    if (maxTime != null)     doneSignal.await(maxTime,TimeUnit.MILLISECONDS);
 else     doneSignal.await();
    if (errors.get() > 0) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      RuntimeException exception=new RuntimeException(message);
      logger.error(exception,message);
    }
    if (logger.isTraceEnabled()) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      logger.trace(message);
    }
  }
 catch (  InterruptedException e) {
    String message=message(logPrefix,total,complete.get(),errors.get(),start);
    TimeoutException exception=new TimeoutException(message);
    logger.error(exception,message);
    Throwables.propagate(exception);
  }
  return errorMap;
}
