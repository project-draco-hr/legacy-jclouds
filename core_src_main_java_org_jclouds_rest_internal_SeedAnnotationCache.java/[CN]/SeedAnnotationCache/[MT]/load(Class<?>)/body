{
  Cache<MethodKey,Method> delegationMap=CacheBuilder.newBuilder().<MethodKey,Method>build();
  for (  Method method : difference(ImmutableSet.copyOf(declaring.getMethods()),ImmutableSet.copyOf(Object.class.getMethods()))) {
    if (isHttpMethod(method) || method.isAnnotationPresent(Delegate.class)) {
      for (int index=0; index < method.getParameterTypes().length; index++) {
        methodToIndexOfParamToBinderParamAnnotation.get(method).get(index);
        methodToIndexOfParamToWrapWithAnnotation.get(method).get(index);
        methodToIndexOfParamToHeaderParamAnnotations.get(method).get(index);
        methodToIndexOfParamToFormParamAnnotations.get(method).get(index);
        methodToIndexOfParamToQueryParamAnnotations.get(method).get(index);
        methodToIndexOfParamToEndpointAnnotations.get(method).get(index);
        methodToIndexOfParamToEndpointParamAnnotations.get(method).get(index);
        methodToIndexOfParamToPathParamAnnotations.get(method).get(index);
        methodToIndexOfParamToPostParamAnnotations.get(method).get(index);
        methodToIndexOfParamToParamParserAnnotations.get(method).get(index);
        methodToIndexOfParamToPartParamAnnotations.get(method).get(index);
        methodToIndexesOfOptions.get(method);
      }
      delegationMap.get(new MethodKey(method),Callables.returning(method));
    }
 else     if (!method.getDeclaringClass().equals(declaring)) {
      logger.trace("skipping potentially overridden method %s",method);
    }
 else     if (method.isAnnotationPresent(Provides.class)) {
      logger.trace("skipping provider method %s",method);
    }
 else {
      logger.trace("Method is not annotated as either http or provider method: %s",method);
    }
  }
  return delegationMap;
}
