{
  Map<F,Exception> exceptions=newHashMap();
  Map<F,Future<T>> responses=newHashMap();
  for (int i=0; i < maxRetries; i++) {
    for (    F from : fromIterable) {
      responses.put(from,function.apply(from));
    }
    exceptions=awaitCompletion(responses,exec,maxTime,logger,logPrefix);
    if (exceptions.size() > 0 && !any(exceptions.values(),containsThrowable(AuthorizationException.class))) {
      fromIterable=exceptions.keySet();
      retryHandler.imposeBackoffExponentialDelay(delayStart,2,i + 1,maxRetries,String.format("error %s: %s: %s",logPrefix,fromIterable,exceptions));
    }
 else {
      break;
    }
  }
  if (exceptions.size() > 0)   return propagateAuthorizationOrOriginalException(new TransformParallelException((Map)responses,exceptions,logPrefix));
  return unwrap(responses.values());
}
