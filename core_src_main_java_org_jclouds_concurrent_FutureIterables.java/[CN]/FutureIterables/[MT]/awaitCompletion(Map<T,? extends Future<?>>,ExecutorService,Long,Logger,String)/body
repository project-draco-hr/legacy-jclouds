{
  final ConcurrentMap<T,Exception> errorMap=newConcurrentMap();
  if (responses.size() == 0)   return errorMap;
  final int total=responses.size();
  final CountDownLatch doneSignal=new CountDownLatch(total);
  final AtomicInteger complete=new AtomicInteger(0);
  final AtomicInteger errors=new AtomicInteger(0);
  final long start=System.currentTimeMillis();
  for (  final java.util.Map.Entry<T,? extends Future<?>> future : responses.entrySet()) {
    Futures.makeListenable(future.getValue(),exec).addListener(new Runnable(){
      @Override public void run(){
        try {
          future.getValue().get();
          complete.incrementAndGet();
        }
 catch (        Exception e) {
          errors.incrementAndGet();
          logException(logger,logPrefix,total,complete.get(),errors.get(),start,e);
          errorMap.put(future.getKey(),e);
        }
 finally {
          doneSignal.countDown();
        }
      }
      @Override public String toString(){
        return "callGetOnFuture(" + future.getKey() + ","+ future.getValue()+ ")";
      }
    }
,exec);
  }
  try {
    if (maxTime != null) {
      doneSignal.await(maxTime,TimeUnit.MILLISECONDS);
    }
 else {
      doneSignal.await();
    }
    if (errors.get() > 0) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      RuntimeException exception=new RuntimeException(message);
      logger.error(exception,message);
    }
    if (logger.isTraceEnabled()) {
      String message=message(logPrefix,total,complete.get(),errors.get(),start);
      logger.trace(message);
    }
  }
 catch (  InterruptedException e) {
    String message=message(logPrefix,total,complete.get(),errors.get(),start);
    TimeoutException exception=new TimeoutException(message);
    logger.error(exception,message);
    propagate(exception);
  }
  return errorMap;
}
