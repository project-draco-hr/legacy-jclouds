{
  Set<ListenableFuture<Void>> deletes=Sets.newHashSet();
  if ((type == FileType.DIRECTORY) && recursive) {
    for (    DirectoryEntry child : async.listDirectory(fullPath).get(10,TimeUnit.SECONDS)) {
      deletes.add(rm(fullPath + "/" + child.getObjectName(),child.getType(),true));
    }
  }
  for (  ListenableFuture<Void> isdeleted : deletes) {
    isdeleted.get(requestTimeoutMilliseconds,TimeUnit.MILLISECONDS);
  }
  return Futures.compose(async.deletePath(fullPath),new Function<Void,Void>(){
    public Void apply(    Void from){
      try {
        if (!Utils.enventuallyTrue(new Supplier<Boolean>(){
          public Boolean get(){
            return !sync.pathExists(fullPath);
          }
        }
,requestTimeoutMilliseconds)) {
          throw new IllegalStateException(fullPath + " still exists after deleting!");
        }
        return null;
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException(fullPath + " still exists after deleting!",e);
      }
    }
  }
);
}
