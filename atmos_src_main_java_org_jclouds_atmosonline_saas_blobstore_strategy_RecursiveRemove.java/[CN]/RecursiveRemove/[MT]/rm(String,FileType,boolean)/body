{
  Set<ListenableFuture<Void>> responses=Sets.newHashSet();
  if ((type == FileType.DIRECTORY) && recursive) {
    for (    DirectoryEntry child : sync.listDirectory(fullPath)) {
      responses.add(rm(fullPath + "/" + child.getObjectName(),child.getType(),true));
    }
  }
  awaitCompletion(responses,userExecutor,maxTime,logger,String.format("deleting from path: %s",fullPath));
  return Futures.compose(async.deletePath(fullPath),new Function<Void,Void>(){
    public Void apply(    Void from){
      try {
        if (!Utils.enventuallyTrue(new Supplier<Boolean>(){
          public Boolean get(){
            return !sync.pathExists(fullPath);
          }
        }
,maxTime != null ? maxTime : 1000)) {
          throw new IllegalStateException(fullPath + " still exists after deleting!");
        }
        return null;
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException(fullPath + " still exists after deleting!",e);
      }
    }
  }
);
}
