{
  Map<String,ListenableFuture<?>> responses=Maps.newHashMap();
  if ((type == FileType.DIRECTORY) && recursive) {
    for (    DirectoryEntry child : sync.listDirectory(fullPath)) {
      responses.put(fullPath + "/" + child.getObjectName(),rm(fullPath + "/" + child.getObjectName(),child.getType(),true));
    }
  }
  Map<String,Exception> exceptions=awaitCompletion(responses,userExecutor,maxTime,logger,String.format("deleting from path: %s",fullPath));
  if (exceptions.size() > 0)   throw new BlobRuntimeException(String.format("deleting from path %s: %s",fullPath,exceptions));
  return Futures.compose(async.deletePath(fullPath),new Function<Void,Void>(){
    public Void apply(    Void from){
      try {
        if (!Utils.enventuallyTrue(new Supplier<Boolean>(){
          public Boolean get(){
            return !sync.pathExists(fullPath);
          }
        }
,maxTime != null ? maxTime : 1000)) {
          throw new IllegalStateException(fullPath + " still exists after deleting!");
        }
        return null;
      }
 catch (      InterruptedException e) {
        throw new IllegalStateException(fullPath + " still exists after deleting!",e);
      }
    }
  }
);
}
