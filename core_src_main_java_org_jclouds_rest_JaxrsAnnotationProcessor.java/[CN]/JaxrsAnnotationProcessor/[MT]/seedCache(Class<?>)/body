{
  Set<Method> methods=Sets.newHashSet(declaring.getMethods());
  methods=Sets.difference(methods,Sets.newHashSet(Object.class.getMethods()));
  for (  Method method : methods) {
    if (isHttpMethod(method)) {
      for (int index=0; index < method.getParameterTypes().length; index++) {
        methodToIndexOfParamToEntityAnnotation.get(method).get(index);
        methodToIndexOfParamToHeaderParamAnnotations.get(method).get(index);
        methodToIndexOfParamToHostPrefixParamAnnotations.get(method).get(index);
        methodToindexOfParamToQueryParamAnnotations.get(method).get(index);
        methodToindexOfParamToPathParamAnnotations.get(method).get(index);
        methodToindexOfParamToPostParamAnnotations.get(method).get(index);
        methodToindexOfParamToParamParserAnnotations.get(method).get(index);
        methodToIndexesOfOptions.get(method);
      }
      delegationMap.put(new MethodKey(method),method);
    }
 else     if (isConstantDeclaration(method)) {
      bindConstant(method);
    }
 else     if (!method.getDeclaringClass().equals(declaring)) {
      logger.debug("skipping potentially overridden method",method);
    }
 else {
      throw new RuntimeException("Method is not annotated as either http or constant: " + method);
    }
  }
}
