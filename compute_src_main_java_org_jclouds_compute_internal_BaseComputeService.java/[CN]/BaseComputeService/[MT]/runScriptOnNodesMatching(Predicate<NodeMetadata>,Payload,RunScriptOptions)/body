{
  Iterable<NodeMetadata> nodes=verifyParametersAndListNodes(filter,runScript,(options != null) ? options : RunScriptOptions.NONE);
  final Map<NodeMetadata,ExecResponse> execs=Maps.newHashMap();
  final Map<NodeMetadata,Exception> badNodes=Maps.newLinkedHashMap();
  Map<NodeMetadata,Future<Void>> responses=Maps.newHashMap();
  for (  final NodeMetadata node : nodes) {
    responses.put(node,executor.submit(new Callable<Void>(){
      @Override public Void call() throws Exception {
        try {
          RunScriptOnNode callable;
          if (options.isRunAsRoot())           callable=utils.runScriptOnNode(node,"computeserv",runScript);
 else           callable=utils.runScriptOnNodeAsDefaultUser(node,"computeserv",runScript);
          SshClient ssh=utils.createSshClientOncePortIsListeningOnNode(node);
          try {
            ssh.connect();
            callable.setConnection(ssh,logger);
            execs.put(node,callable.call());
          }
  finally {
            if (ssh != null)             ssh.disconnect();
          }
        }
 catch (        Exception e) {
          badNodes.put(node,e);
        }
        return null;
      }
    }
));
  }
  Map<?,Exception> exceptions=awaitCompletion(responses,executor,null,logger,"starting nodes");
  if (exceptions.size() > 0 || badNodes.size() > 0) {
    throw new RunScriptOnNodesException(runScript,options,execs,exceptions,badNodes);
  }
  return execs;
}
