{
  ResponseParser annotation=method.getAnnotation(ResponseParser.class);
  if (annotation == null) {
    if (method.getReturnType().equals(void.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureVoidLiteral)) {
      return Key.get(ReleasePayloadAndReturn.class);
    }
 else     if (method.getReturnType().equals(boolean.class) || method.getReturnType().equals(Boolean.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureBooleanLiteral)) {
      return Key.get(ReturnTrueIf2xx.class);
    }
 else     if (method.getReturnType().equals(InputStream.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureInputStreamLiteral)) {
      return Key.get(ReturnInputStream.class);
    }
 else     if (method.getReturnType().equals(HttpResponse.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureHttpResponseLiteral)) {
      return Key.get((Class)IdentityFunction.class);
    }
 else     if (getAcceptHeadersOrNull(method).contains(MediaType.APPLICATION_JSON)) {
      Type returnVal;
      if (method.getReturnType().getTypeParameters().length == 0) {
        returnVal=method.getReturnType();
      }
 else       if (method.getReturnType().equals(ListenableFuture.class)) {
        ParameterizedType futureType=((ParameterizedType)method.getGenericReturnType());
        returnVal=futureType.getActualTypeArguments()[0];
        if (returnVal instanceof WildcardType)         returnVal=WildcardType.class.cast(returnVal).getUpperBounds()[0];
      }
 else {
        returnVal=method.getGenericReturnType();
      }
      ParameterizedType parserType;
      if (method.isAnnotationPresent(Unwrap.class)) {
        int depth=method.getAnnotation(Unwrap.class).depth();
        Class edgeCollection=method.getAnnotation(Unwrap.class).edgeCollection();
        if (depth == 1 && edgeCollection == Map.class)         parserType=Types.newParameterizedType(UnwrapOnlyJsonValue.class,returnVal);
 else         if (depth == 2 && edgeCollection == Map.class)         parserType=Types.newParameterizedType(UnwrapOnlyNestedJsonValue.class,returnVal);
 else         if (depth == 3 && edgeCollection == Set.class)         parserType=Types.newParameterizedType(UnwrapOnlyNestedJsonValueInSet.class,returnVal);
 else         throw new IllegalStateException(String.format("depth(%d) edgeCollection(%s) not yet supported for @Unwrap",depth,edgeCollection));
      }
 else {
        parserType=Types.newParameterizedType(ParseJson.class,returnVal);
      }
      return (Key<? extends Function<HttpResponse,?>>)Key.get(parserType);
    }
 else     if (method.getReturnType().equals(String.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureStringLiteral)) {
      return Key.get(ReturnStringIf2xx.class);
    }
 else     if (method.getReturnType().equals(URI.class) || TypeLiteral.get(method.getGenericReturnType()).equals(futureURILiteral)) {
      return Key.get(ParseURIFromListOrLocationHeaderIf20x.class);
    }
 else {
      throw new IllegalStateException("You must specify a ResponseParser annotation on: " + method.toString());
    }
  }
  return Key.get(annotation.value());
}
