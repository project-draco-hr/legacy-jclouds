{
  Multimap<String,String> queryParamValues=LinkedHashMultimap.create();
  LoadingCache<Integer,Set<Annotation>> indexToQueryParam=methodToIndexOfParamToQueryParamAnnotations.getUnchecked(method);
  LoadingCache<Integer,Set<Annotation>> indexToParamExtractor=methodToIndexOfParamToParamParserAnnotations.getUnchecked(method);
  for (  Entry<Integer,Set<Annotation>> entry : indexToQueryParam.asMap().entrySet()) {
    for (    Annotation key : entry.getValue()) {
      Set<Annotation> extractors=indexToParamExtractor.getUnchecked(entry.getKey());
      String paramKey=((QueryParam)key).value();
      Optional<?> paramValue=getParamValue(method,args,extractors,entry,paramKey);
      if (paramValue.isPresent()) {
        if (paramValue.get() instanceof Iterable) {
          Iterable<String> iterableStrings=transform(Iterable.class.cast(paramValue.get()),toStringFunction());
          queryParamValues.putAll(paramKey,iterableStrings);
        }
 else {
          queryParamValues.put(paramKey,paramValue.get().toString());
        }
      }
    }
  }
  if (method.isAnnotationPresent(QueryParam.class) && method.isAnnotationPresent(ParamParser.class)) {
    String paramKey=method.getAnnotation(QueryParam.class).value();
    String paramValue=injector.getInstance(method.getAnnotation(ParamParser.class).value()).apply(args);
    queryParamValues.put(paramKey,paramValue);
  }
  return queryParamValues;
}
