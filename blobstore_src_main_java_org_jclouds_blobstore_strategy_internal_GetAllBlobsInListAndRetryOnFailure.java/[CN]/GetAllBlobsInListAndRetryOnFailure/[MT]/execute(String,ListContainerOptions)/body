{
  Map<BlobMetadata,Exception> exceptions=Maps.newHashMap();
  final Set<Blob> objects=Sets.newHashSet();
  Iterable<? extends BlobMetadata> toGet=getAllBlobMetadata.execute(container,options);
  for (int i=0; i < 3; i++) {
    Map<BlobMetadata,ListenableFuture<?>> responses=Maps.newHashMap();
    for (    BlobMetadata md : toGet) {
      final ListenableFuture<? extends Blob> future=ablobstore.getBlob(container,md.getName());
      future.addListener(new Runnable(){
        @Override public void run(){
          try {
            objects.add(future.get());
          }
 catch (          InterruptedException e) {
            Throwables.propagate(e);
          }
catch (          ExecutionException e) {
            Throwables.propagate(e);
          }
        }
      }
,Executors.sameThreadExecutor());
      responses.put(md,ablobstore.getBlob(container,md.getName()));
    }
    exceptions=awaitCompletion(responses,userExecutor,maxTime,logger,String.format("getting from containerName: %s",container));
    if (exceptions.size() > 0) {
      toGet=exceptions.keySet();
      retryHandler.imposeBackoffExponentialDelay(i + 1,String.format("blob %s/%s not found",container,toGet));
    }
 else {
      break;
    }
  }
  if (exceptions.size() > 0)   throw new BlobRuntimeException(String.format("errors getting from container %s: %s",container,exceptions));
  return objects;
}
