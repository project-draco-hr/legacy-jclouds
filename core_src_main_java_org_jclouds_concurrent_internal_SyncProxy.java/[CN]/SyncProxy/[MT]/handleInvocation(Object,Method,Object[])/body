{
  if (method.isAnnotationPresent(Delegate.class)) {
    Class<?> syncClass=Optionals2.returnTypeOrTypeOfOptional(method);
    Class<?> asyncClass=sync2Async.get(syncClass);
    checkState(asyncClass != null,"please configure corresponding async class for " + syncClass + " in your RestClientModule");
    ClassMethodArgs cma=new ClassMethodArgs(asyncClass,method,args);
    Object returnVal=delegateMap.get(cma);
    if (Optionals2.isReturnTypeOptional(method)) {
      ClassMethodArgsAndReturnVal cmar=ClassMethodArgsAndReturnVal.builder().fromClassMethodArgs(cma).returnVal(returnVal).build();
      return optionalConverter.apply(cmar);
    }
    return returnVal;
  }
 else   if (syncMethodMap.containsKey(method)) {
    try {
      return syncMethodMap.get(method).invoke(delegate,args);
    }
 catch (    InvocationTargetException e) {
      throw Throwables.propagate(e.getCause());
    }
  }
 else {
    try {
      Optional<Long> timeoutNanos=timeoutMap.get(method);
      Method asyncMethod=methodMap.get(method);
      String name=asyncMethod.getDeclaringClass().getSimpleName() + "." + asyncMethod.getName();
      ListenableFuture<?> future=((ListenableFuture<?>)asyncMethod.invoke(delegate,args));
      if (timeoutNanos.isPresent()) {
        logger.debug(">> blocking on %s for %s",name,timeoutNanos);
        return future.get(timeoutNanos.get(),TimeUnit.NANOSECONDS);
      }
      logger.debug(">> blocking on %s",name);
      return future.get();
    }
 catch (    ProvisionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    ExecutionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    Exception e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
  }
}
