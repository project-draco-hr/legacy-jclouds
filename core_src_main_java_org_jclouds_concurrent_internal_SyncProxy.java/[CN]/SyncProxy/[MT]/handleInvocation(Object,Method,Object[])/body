{
  if (method.isAnnotationPresent(Delegate.class)) {
    Class<?> syncClass=Optionals2.returnTypeOrTypeOfOptional(method);
    Class<?> asyncClass=sync2Async.get(syncClass);
    checkState(asyncClass != null,"please configure corresponding async class for " + syncClass + " in your RestClientModule");
    ClassMethodArgs cma=new ClassMethodArgs(asyncClass,method,args);
    Object returnVal=delegateMap.get(cma);
    if (Optionals2.isReturnTypeOptional(method)) {
      ClassMethodArgsAndReturnVal cmar=ClassMethodArgsAndReturnVal.builder().fromClassMethodArgs(cma).returnVal(returnVal).build();
      return optionalConverter.apply(cmar);
    }
    return returnVal;
  }
 else   if (syncMethodMap.containsKey(method)) {
    try {
      return syncMethodMap.get(method).invoke(delegate,args);
    }
 catch (    InvocationTargetException e) {
      throw Throwables.propagate(e.getCause());
    }
  }
 else {
    try {
      ListenableFuture<?> future=((ListenableFuture<?>)methodMap.get(method).invoke(delegate,args));
      Optional<Long> timeoutNanos=timeoutMap.get(method);
      if (timeoutNanos.isPresent())       return future.get(timeoutNanos.get(),TimeUnit.NANOSECONDS);
      return future.get();
    }
 catch (    ProvisionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    ExecutionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    Exception e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
  }
}
