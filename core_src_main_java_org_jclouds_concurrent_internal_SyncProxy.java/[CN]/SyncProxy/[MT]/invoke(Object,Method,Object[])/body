{
  if (method.getName().equals("equals")) {
    return this.equals(o);
  }
 else   if (method.getName().equals("hashCode")) {
    return this.hashCode();
  }
 else   if (method.getName().equals("toString")) {
    return this.toString();
  }
 else   if (method.isAnnotationPresent(Delegate.class)) {
    Class<?> syncClass=Optionals2.returnTypeOrTypeOfOptional(method);
    Class<?> asyncClass=sync2Async.get(syncClass);
    checkState(asyncClass != null,"please configure corresponding async class for " + syncClass + " in your RestClientModule");
    ClassMethodArgs cma=new ClassMethodArgs(asyncClass,method,args);
    Object returnVal=delegateMap.get(cma);
    if (Optionals2.isReturnTypeOptional(method)) {
      ClassMethodArgsAndReturnVal cmar=ClassMethodArgsAndReturnVal.builder().fromClassMethodArgs(cma).returnVal(returnVal).build();
      return optionalConverter.apply(cmar);
    }
    return returnVal;
  }
 else   if (syncMethodMap.containsKey(method)) {
    try {
      return syncMethodMap.get(method).invoke(delegate,args);
    }
 catch (    InvocationTargetException e) {
      throw Throwables.propagate(e.getCause());
    }
  }
 else {
    try {
      return ((ListenableFuture<?>)methodMap.get(method).invoke(delegate,args)).get(timeoutMap.get(method),TimeUnit.NANOSECONDS);
    }
 catch (    ProvisionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    ExecutionException e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    Exception e) {
      throw Throwables2.returnFirstExceptionIfInListOrThrowStandardExceptionOrCause(method.getExceptionTypes(),e);
    }
  }
}
