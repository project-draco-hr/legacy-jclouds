{
  if (method.getName().equals("equals")) {
    return this.equals(o);
  }
 else   if (method.getName().equals("hashCode")) {
    return this.hashCode();
  }
 else   if (method.getName().equals("toString")) {
    return this.toString();
  }
 else   if (method.isAnnotationPresent(Delegate.class)) {
    Class<?> asyncClass=sync2Async.get(method.getReturnType());
    checkState(asyncClass != null,"please configure corresponding async class for " + method.getReturnType() + " in your RestClientModule");
    Object returnVal=delegateMap.get(new ClassMethodArgs(asyncClass,method,args));
    return returnVal;
  }
 else   if (syncMethodMap.containsKey(method)) {
    return syncMethodMap.get(method).invoke(delegate,args);
  }
 else {
    try {
      return ((ListenableFuture<?>)methodMap.get(method).invoke(delegate,args)).get(timeoutMap.get(method),TimeUnit.NANOSECONDS);
    }
 catch (    ExecutionException e) {
      throw throwTypedExceptionOrCause(method.getExceptionTypes(),e);
    }
catch (    Exception e) {
      throw throwTypedExceptionOrCause(method.getExceptionTypes(),e);
    }
  }
}
