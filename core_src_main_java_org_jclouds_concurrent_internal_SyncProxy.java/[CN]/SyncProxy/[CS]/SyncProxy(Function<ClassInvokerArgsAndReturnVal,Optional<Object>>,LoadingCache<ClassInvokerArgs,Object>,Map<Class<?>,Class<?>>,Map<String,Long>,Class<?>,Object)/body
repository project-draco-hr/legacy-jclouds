{
  this.optionalConverter=optionalConverter;
  this.delegateMap=delegateMap;
  this.delegate=async;
  this.declaring=declaring;
  this.sync2Async=ImmutableMap.copyOf(sync2Async);
  ImmutableMap.Builder<Invokable<?,?>,Invokable<Object,ListenableFuture<?>>> methodMapBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<Invokable<?,?>,Invokable<Object,?>> syncMethodMapBuilder=ImmutableMap.builder();
  for (  Method method : declaring.getMethods()) {
    if (!objectMethods.contains(method)) {
      Method delegatedMethod=delegate.getClass().getMethod(method.getName(),method.getParameterTypes());
      if (!Arrays.equals(delegatedMethod.getExceptionTypes(),method.getExceptionTypes()))       throw new IllegalArgumentException(String.format("method %s has different typed exceptions than delegated method %s",method,delegatedMethod));
      if (delegatedMethod.getReturnType().isAssignableFrom(ListenableFuture.class)) {
        methodMapBuilder.put(Invokable.from(method),Invokable.class.cast(Invokable.from(delegatedMethod)));
      }
 else {
        syncMethodMapBuilder.put(Invokable.from(method),Invokable.class.cast(Invokable.from(delegatedMethod)));
      }
    }
  }
  methodMap=methodMapBuilder.build();
  syncMethodMap=syncMethodMapBuilder.build();
  ImmutableMap.Builder<Invokable<?,?>,Optional<Long>> timeoutMapBuilder=ImmutableMap.builder();
  for (  Invokable<?,?> method : methodMap.keySet()) {
    timeoutMapBuilder.put(method,timeoutInNanos(method,timeouts));
  }
  timeoutMap=timeoutMapBuilder.build();
}
