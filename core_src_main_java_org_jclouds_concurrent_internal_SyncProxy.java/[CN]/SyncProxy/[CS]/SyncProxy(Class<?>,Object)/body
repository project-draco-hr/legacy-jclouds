{
  this.delegate=delegate;
  this.declaring=declaring;
  if (!declaring.isAnnotationPresent(Timeout.class)) {
    throw new IllegalArgumentException(String.format("type %s does not specify a default @Timeout",declaring));
  }
  Timeout typeTimeout=declaring.getAnnotation(Timeout.class);
  long typeNanos=convertToNanos(typeTimeout);
  methodMap=Maps.newHashMap();
  syncMethodMap=Maps.newHashMap();
  timeoutMap=Maps.newHashMap();
  for (  Method method : declaring.getMethods()) {
    if (!objectMethods.contains(method)) {
      Method delegatedMethod=delegate.getClass().getMethod(method.getName(),method.getParameterTypes());
      if (!Arrays.equals(delegatedMethod.getExceptionTypes(),method.getExceptionTypes()))       throw new IllegalArgumentException(String.format("method %s has different typed exceptions than delegated method %s",method,delegatedMethod));
      if (delegatedMethod.getReturnType().isAssignableFrom(ListenableFuture.class)) {
        if (method.isAnnotationPresent(Timeout.class)) {
          Timeout methodTimeout=method.getAnnotation(Timeout.class);
          long methodNanos=convertToNanos(methodTimeout);
          timeoutMap.put(method,methodNanos);
        }
 else {
          timeoutMap.put(method,typeNanos);
        }
        methodMap.put(method,delegatedMethod);
      }
 else {
        syncMethodMap.put(method,delegatedMethod);
      }
    }
  }
}
