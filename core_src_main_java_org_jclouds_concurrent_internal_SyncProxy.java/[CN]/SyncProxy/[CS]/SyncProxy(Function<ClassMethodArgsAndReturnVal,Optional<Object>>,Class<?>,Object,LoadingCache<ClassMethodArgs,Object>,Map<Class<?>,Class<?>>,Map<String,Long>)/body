{
  this.optionalConverter=optionalConverter;
  this.delegateMap=delegateMap;
  this.delegate=async;
  this.declaring=declaring;
  this.sync2Async=sync2Async;
  if (!declaring.isAnnotationPresent(Timeout.class)) {
    throw new IllegalArgumentException(String.format("type %s does not specify a default @Timeout",declaring));
  }
  Timeout typeTimeout=declaring.getAnnotation(Timeout.class);
  long typeNanos=convertToNanos(typeTimeout);
  methodMap=Maps.newHashMap();
  syncMethodMap=Maps.newHashMap();
  timeoutMap=Maps.newHashMap();
  for (  Method method : declaring.getMethods()) {
    if (!objectMethods.contains(method)) {
      Method delegatedMethod=delegate.getClass().getMethod(method.getName(),method.getParameterTypes());
      if (!Arrays.equals(delegatedMethod.getExceptionTypes(),method.getExceptionTypes()))       throw new IllegalArgumentException(String.format("method %s has different typed exceptions than delegated method %s",method,delegatedMethod));
      if (delegatedMethod.getReturnType().isAssignableFrom(ListenableFuture.class)) {
        timeoutMap.put(method,getTimeout(method,typeNanos,timeouts));
        methodMap.put(method,delegatedMethod);
      }
 else {
        syncMethodMap.put(method,delegatedMethod);
      }
    }
  }
}
