{
  this.optionalConverter=optionalConverter;
  this.delegateMap=delegateMap;
  this.delegate=async;
  this.declaring=declaring;
  this.sync2Async=ImmutableMap.copyOf(sync2Async);
  if (!declaring.isAnnotationPresent(Timeout.class)) {
    throw new IllegalArgumentException(String.format("type %s does not specify a default @Timeout",declaring));
  }
  Timeout typeTimeout=declaring.getAnnotation(Timeout.class);
  long typeNanos=convertToNanos(typeTimeout);
  ImmutableMap.Builder<Method,Method> methodMapBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<Method,Method> syncMethodMapBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<Method,Long> timeoutMapBuilder=ImmutableMap.builder();
  for (  Method method : declaring.getMethods()) {
    if (!objectMethods.contains(method)) {
      Method delegatedMethod=delegate.getClass().getMethod(method.getName(),method.getParameterTypes());
      if (!Arrays.equals(delegatedMethod.getExceptionTypes(),method.getExceptionTypes()))       throw new IllegalArgumentException(String.format("method %s has different typed exceptions than delegated method %s",method,delegatedMethod));
      if (delegatedMethod.getReturnType().isAssignableFrom(ListenableFuture.class)) {
        timeoutMapBuilder.put(method,getTimeout(method,typeNanos,timeouts));
        methodMapBuilder.put(method,delegatedMethod);
      }
 else {
        syncMethodMapBuilder.put(method,delegatedMethod);
      }
    }
  }
  methodMap=methodMapBuilder.build();
  syncMethodMap=syncMethodMapBuilder.build();
  timeoutMap=timeoutMapBuilder.build();
}
