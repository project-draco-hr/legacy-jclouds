{
  this.optionalConverter=optionalConverter;
  this.createClientForCaller=createClientForCaller;
  this.delegate=async;
  this.declaring=declaring;
  this.sync2Async=ImmutableMap.copyOf(sync2Async);
  ImmutableMap.Builder<Invokable<?,?>,Invokable<Object,ListenableFuture<?>>> invokedMapBuilder=ImmutableMap.builder();
  ImmutableMap.Builder<Invokable<?,?>,Invokable<Object,?>> syncMethodMapBuilder=ImmutableMap.builder();
  for (  Method invoked : declaring.getMethods()) {
    if (!objectMethods.contains(invoked)) {
      Method delegatedMethod=delegate.getClass().getMethod(invoked.getName(),invoked.getParameterTypes());
      if (!Arrays.equals(delegatedMethod.getExceptionTypes(),invoked.getExceptionTypes()))       throw new IllegalArgumentException(String.format("invoked %s has different typed exceptions than delegated invoked %s",invoked,delegatedMethod));
      if (delegatedMethod.getReturnType().isAssignableFrom(ListenableFuture.class)) {
        invokedMapBuilder.put(Invokable.from(invoked),Invokable.class.cast(Invokable.from(delegatedMethod)));
      }
 else {
        syncMethodMapBuilder.put(Invokable.from(invoked),Invokable.class.cast(Invokable.from(delegatedMethod)));
      }
    }
  }
  invokedMap=invokedMapBuilder.build();
  syncMethodMap=syncMethodMapBuilder.build();
  ImmutableMap.Builder<Invokable<?,?>,Optional<Long>> timeoutMapBuilder=ImmutableMap.builder();
  for (  Invokable<?,?> invoked : invokedMap.keySet()) {
    timeoutMapBuilder.put(invoked,timeoutInNanos(invoked,timeouts));
  }
  timeoutMap=timeoutMapBuilder.build();
}
