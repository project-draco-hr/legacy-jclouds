{
  long unitPartSize=DEFAULT_PART_SIZE;
  long parts=length / unitPartSize;
  long partSize=unitPartSize;
  int magnitude=(int)(parts / MAGNITUDE_BASE);
  if (magnitude > 0) {
    partSize=magnitude * unitPartSize;
    if (partSize > MAX_PART_SIZE) {
      partSize=MAX_PART_SIZE;
      unitPartSize=MAX_PART_SIZE;
    }
    parts=length / partSize;
    if (parts * partSize < length) {
      partSize=(magnitude + 1) * unitPartSize;
      if (partSize > MAX_PART_SIZE) {
        partSize=MAX_PART_SIZE;
        unitPartSize=MAX_PART_SIZE;
      }
      parts=length / partSize;
    }
  }
  if (parts > MAX_NUMBER_OF_PARTS) {
    unitPartSize=MIN_PART_SIZE;
    parts=length / unitPartSize;
  }
  if (parts > MAX_NUMBER_OF_PARTS) {
    parts=MAX_NUMBER_OF_PARTS - 1;
  }
  long remainder=length % unitPartSize;
  if (remainder == 0 && parts > 0) {
    parts-=1;
  }
  this.chunkSize=partSize;
  this.parts=parts;
  this.remaining=length - partSize * parts;
  logger.debug(" %d bytes partitioned in %d parts of part size: %d, remaining: %d%s",length,parts,chunkSize,remaining,(remaining > MAX_PART_SIZE ? " overflow!" : ""));
  return this.chunkSize;
}
