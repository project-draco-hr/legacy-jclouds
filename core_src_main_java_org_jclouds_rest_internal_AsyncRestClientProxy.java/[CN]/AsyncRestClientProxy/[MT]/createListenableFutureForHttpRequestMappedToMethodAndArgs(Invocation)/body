{
  String name=invocation.getInterfaceType().getSimpleName() + "." + invocation.getInvokable().getName();
  logger.trace(">> converting %s",name);
  FutureFallback<?> fallback=fallbacks.getUnchecked(invocation.getInvokable());
  if (fallback instanceof InvocationContext) {
    InvocationContext.class.cast(fallback).setContext((HttpRequest)null);
  }
  ListenableFuture<?> result;
  try {
    GeneratedHttpRequest request=annotationProcessor.apply(invocation);
    if (fallback instanceof InvocationContext) {
      InvocationContext.class.cast(fallback).setContext(request);
    }
    logger.trace("<< converted %s to %s",name,request.getRequestLine());
    Function<HttpResponse,?> transformer=createResponseParser(parserFactory,injector,invocation,request);
    logger.trace("<< response from %s is parsed by %s",name,transformer.getClass().getSimpleName());
    logger.debug(">> invoking %s",name);
    result=transform(makeListenable(http.submit(new HttpCommand(request)),userThreads),transformer);
  }
 catch (  RuntimeException e) {
    AuthorizationException aex=getFirstThrowableOfType(e,AuthorizationException.class);
    if (aex != null)     e=aex;
    try {
      return fallback.create(e);
    }
 catch (    Exception ex) {
      return immediateFailedFuture(ex);
    }
  }
  logger.trace("<< exceptions from %s are parsed by %s",name,fallback.getClass().getSimpleName());
  return withFallback(result,fallback);
}
