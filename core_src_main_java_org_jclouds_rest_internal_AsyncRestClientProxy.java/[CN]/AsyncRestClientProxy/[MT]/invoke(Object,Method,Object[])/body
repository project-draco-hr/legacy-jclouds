{
  if (method.getName().equals("equals")) {
    return this.equals(o);
  }
 else   if (method.getName().equals("toString")) {
    return this.toString();
  }
 else   if (method.getName().equals("hashCode")) {
    return this.hashCode();
  }
 else   if (method.isAnnotationPresent(Provides.class)) {
    try {
      Annotation qualifier=Iterables.find(ImmutableList.copyOf(method.getAnnotations()),isQualifierPresent);
      return injector.getInstance(Key.get(method.getGenericReturnType(),qualifier));
    }
 catch (    NoSuchElementException e) {
      return injector.getInstance(Key.get(method.getGenericReturnType()));
    }
  }
 else   if (method.isAnnotationPresent(Delegate.class)) {
    return delegateMap.get(new ClassMethodArgs(method.getReturnType(),method,args));
  }
 else   if (annotationProcessor.getDelegateOrNull(method) != null && ListenableFuture.class.isAssignableFrom(method.getReturnType())) {
    return createListenableFuture(method,args);
  }
 else {
    throw new RuntimeException("method is intended solely to set constants: " + method);
  }
}
