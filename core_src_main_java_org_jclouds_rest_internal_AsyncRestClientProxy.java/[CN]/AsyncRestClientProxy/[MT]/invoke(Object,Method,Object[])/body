{
  if (method.getName().equals("equals")) {
    return this.equals(o);
  }
 else   if (method.getName().equals("hashCode")) {
    return this.hashCode();
  }
 else   if (method.getName().startsWith("new")) {
    return injector.getInstance(method.getReturnType());
  }
 else   if (util.getDelegateOrNull(method) != null && Future.class.isAssignableFrom(method.getReturnType())) {
    method=util.getDelegateOrNull(method);
    logger.trace("Converting %s.%s",declaring.getSimpleName(),method.getName());
    Function<Exception,?> exceptionParser=util.createExceptionParserOrThrowResourceNotFoundOn404IfNoAnnotation(method);
    if (exceptionParser instanceof InvocationContext) {
      ((InvocationContext)exceptionParser).setContext(null);
    }
    GeneratedHttpRequest<T> request;
    try {
      request=util.createRequest(method,args);
      if (exceptionParser instanceof InvocationContext) {
        ((InvocationContext)exceptionParser).setContext(request);
      }
    }
 catch (    RuntimeException e) {
      if (exceptionParser != null) {
        final Object toReturn=exceptionParser.apply(e);
        if (toReturn == null)         throw e;
        if (method.getReturnType().isAssignableFrom(Future.class)) {
          return new Future<Object>(){
            public boolean cancel(            boolean mayInterruptIfRunning){
              return false;
            }
            public Object get() throws InterruptedException, ExecutionException {
              return toReturn;
            }
            public Object get(            long timeout,            TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {
              return get();
            }
            public boolean isCancelled(){
              return false;
            }
            public boolean isDone(){
              return true;
            }
          }
;
        }
 else {
          return toReturn;
        }
      }
      throw e;
    }
    logger.debug("Converted %s.%s to %s",declaring.getSimpleName(),method.getName(),request.getRequestLine());
    Function<HttpResponse,?> transformer=util.createResponseParser(method,request);
    logger.trace("Response from %s.%s is parsed by %s",declaring.getSimpleName(),method.getName(),transformer.getClass().getSimpleName());
    logger.debug("Invoking %s.%s",declaring.getSimpleName(),method.getName());
    Future<?> result=commandFactory.create(request,transformer,exceptionParser).execute();
    if (exceptionParser != null) {
      logger.trace("Exceptions from %s.%s are parsed by %s",declaring.getSimpleName(),method.getName(),exceptionParser.getClass().getSimpleName());
      result=new FutureExceptionParser(result,exceptionParser);
    }
    if (method.getReturnType().isAssignableFrom(Future.class)) {
      return result;
    }
 else {
      logger.debug("Blocking up to %dms for %s.%s to complete",requestTimeoutMilliseconds,declaring.getSimpleName(),method.getName());
      return result.get(requestTimeoutMilliseconds,TimeUnit.MILLISECONDS);
    }
  }
 else {
    throw new RuntimeException("method is intended solely to set constants: " + method);
  }
}
