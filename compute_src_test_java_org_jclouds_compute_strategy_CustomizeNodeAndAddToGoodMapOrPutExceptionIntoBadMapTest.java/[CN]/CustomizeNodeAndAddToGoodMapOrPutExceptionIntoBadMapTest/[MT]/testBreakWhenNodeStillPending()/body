{
  InitializeRunScriptOnNodeOrPlaceInBadMap.Factory initScriptRunnerFactory=createMock(InitializeRunScriptOnNodeOrPlaceInBadMap.Factory.class);
  OpenSocketFinder openSocketFinder=createMock(OpenSocketFinder.class);
  Timeouts timeouts=new Timeouts();
  Function<TemplateOptions,Statement> templateOptionsToStatement=new TemplateOptionsToStatement();
  @SuppressWarnings("unused") Statement statement=null;
  TemplateOptions options=new TemplateOptions();
  Set<NodeMetadata> goodNodes=Sets.newLinkedHashSet();
  Map<NodeMetadata,Exception> badNodes=Maps.newLinkedHashMap();
  Multimap<NodeMetadata,CustomizationResponse> customizationResponses=LinkedHashMultimap.create();
  final NodeMetadata node=new NodeMetadataBuilder().ids("id").state(NodeState.PENDING).build();
  GetNodeMetadataStrategy nodeRunning=new GetNodeMetadataStrategy(){
    @Override public NodeMetadata getNode(    String input){
      Assert.assertEquals(input,node.getId());
      return node;
    }
  }
;
  replay(initScriptRunnerFactory,openSocketFinder);
  AtomicReference<NodeMetadata> atomicNode=new AtomicReference<NodeMetadata>(node);
  new CustomizeNodeAndAddToGoodMapOrPutExceptionIntoBadMap(new AtomicNodeRunning(nodeRunning),openSocketFinder,timeouts,templateOptionsToStatement,initScriptRunnerFactory,options,atomicNode,goodNodes,badNodes,customizationResponses).apply(atomicNode);
  assertEquals(goodNodes.size(),0);
  assertEquals(badNodes.keySet(),ImmutableSet.of(node));
  assertTrue(badNodes.get(node).getMessage() != null && badNodes.get(node).getMessage().matches("node\\(id\\) didn't achieve the state running, so we couldn't customize; aborting prematurely after .* seconds with final state: PENDING"),badNodes.get(node).getMessage());
  assertEquals(customizationResponses.size(),0);
  verify(initScriptRunnerFactory,openSocketFinder);
}
