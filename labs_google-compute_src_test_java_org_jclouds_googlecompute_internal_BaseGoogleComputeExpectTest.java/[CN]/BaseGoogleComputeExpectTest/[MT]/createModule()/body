{
  return new Module(){
    @Override public void configure(    Binder binder){
      binder.bind(Ticker.class).toInstance(new Ticker(){
        @Override public long read(){
          return 0;
        }
      }
);
      try {
        KeyFactory keyfactory=KeyFactory.getInstance("RSA");
        PrivateKey privateKey=keyfactory.generatePrivate(privateKeySpec(newStringPayload(PRIVATE_KEY)));
        PublicKey publicKey=keyfactory.generatePublic(publicKeySpec(newStringPayload(PUBLIC_KEY)));
        KeyPair keyPair=new KeyPair(publicKey,privateKey);
        openSshKey=SshKeys.encodeAsOpenSSH(RSAPublicKey.class.cast(publicKey));
        final Crypto crypto=createMock(Crypto.class);
        KeyPairGenerator rsaKeyPairGenerator=createMock(KeyPairGenerator.class);
        final SecureRandom secureRandom=createMock(SecureRandom.class);
        expect(crypto.rsaKeyPairGenerator()).andReturn(rsaKeyPairGenerator).anyTimes();
        rsaKeyPairGenerator.initialize(2048,secureRandom);
        expectLastCall().anyTimes();
        expect(rsaKeyPairGenerator.genKeyPair()).andReturn(keyPair).anyTimes();
        replay(crypto,rsaKeyPairGenerator,secureRandom);
        binder.bind(Crypto.class).toInstance(crypto);
        binder.bind(SecureRandom.class).toInstance(secureRandom);
      }
 catch (      NoSuchAlgorithmException e) {
        propagate(e);
      }
catch (      InvalidKeySpecException e) {
        propagate(e);
      }
catch (      IOException e) {
        propagate(e);
      }
      final AtomicInteger suffix=new AtomicInteger();
      binder.bind(new TypeLiteral<Supplier<String>>(){
      }
).toInstance(new Supplier<String>(){
        @Override public String get(){
          return suffix.getAndIncrement() + "";
        }
      }
);
    }
  }
;
}
