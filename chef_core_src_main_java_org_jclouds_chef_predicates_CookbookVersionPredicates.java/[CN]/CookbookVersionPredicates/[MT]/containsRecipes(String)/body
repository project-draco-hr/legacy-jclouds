{
  checkNotNull(recipes,"recipes must be defined");
  final Multimap<String,String> search=LinkedListMultimap.create();
  for (  String recipe : recipes) {
    if (recipe.indexOf("::") != -1) {
      Iterable<String> nameRecipe=Splitter.on("::").split(recipe);
      search.put(get(nameRecipe,0),get(nameRecipe,1) + ".rb");
    }
 else {
      search.put(recipe,"default.rb");
    }
  }
  return new Predicate<CookbookVersion>(){
    @Override public boolean apply(    final CookbookVersion cookbookVersion){
      return search.containsKey(cookbookVersion.getCookbookName()) && any(search.get(cookbookVersion.getCookbookName()),new Predicate<String>(){
        @Override public boolean apply(        final String recipeName){
          return any(cookbookVersion.getRecipes(),new Predicate<Resource>(){
            @Override public boolean apply(            Resource resource){
              return resource.getName().equals(recipeName);
            }
          }
);
        }
      }
);
    }
    @Override public String toString(){
      return "containsRecipes(" + search + ")";
    }
  }
;
}
