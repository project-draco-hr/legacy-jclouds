{
  String message="1";
  long timeOut=messageCount * 200;
  for (  Queue queue : queues) {
    int complete=0;
    int errors=0;
    long start=System.currentTimeMillis();
    Set<ListenableFuture<byte[]>> responses=Sets.newHashSet();
    for (int i=0; i < messageCount; i++) {
      responses.add(context.getAsyncApi().sendMessage(queue,message));
    }
    do {
      Set<ListenableFuture<byte[]>> retries=Sets.newHashSet();
      for (      ListenableFuture<byte[]> response : responses) {
        try {
          response.get(100,TimeUnit.MILLISECONDS);
          complete++;
        }
 catch (        ExecutionException e) {
          System.err.println(e.getMessage());
          errors++;
        }
catch (        TimeoutException e) {
          retries.add(response);
        }
      }
      responses=Sets.newHashSet(retries);
    }
 while (responses.size() > 0 && System.currentTimeMillis() < start + timeOut);
    long duration=System.currentTimeMillis() - start;
    if (duration > timeOut)     System.out.printf("TIMEOUT: context: %s, region: %s, rate: %f messages/second%n",contextName,queue.getRegion(),((double)complete) / (duration / 1000.0));
 else     System.out.printf("COMPLETE:  context: %s, region: %s, rate: %f messages/second%n",contextName,queue.getRegion(),((double)complete) / (duration / 1000.0));
    System.gc();
    System.out.println("pausing 5 seconds before the next run");
    Thread.sleep(5000);
  }
}
