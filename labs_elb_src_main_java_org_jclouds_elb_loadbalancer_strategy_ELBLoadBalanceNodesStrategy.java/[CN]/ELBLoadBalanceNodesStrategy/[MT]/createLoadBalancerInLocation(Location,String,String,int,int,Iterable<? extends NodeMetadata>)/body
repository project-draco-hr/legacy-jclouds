{
  checkNotNull(location,"location");
  String region=getRegionFromLocationOrNull(location);
  Set<String> availabilityZones=ImmutableSet.copyOf(transform(nodes,new Function<NodeMetadata,String>(){
    @Override public String apply(    NodeMetadata from){
      return from.getLocation().getId();
    }
  }
));
  logger.debug(">> creating loadBalancer(%s)",name);
  try {
    String dnsName=client.createLoadBalancerInRegion(region,name,protocol,loadBalancerPort,instancePort,availabilityZones.toArray(new String[]{}));
    logger.debug("<< created loadBalancer(%s) dnsName(%s)",name,dnsName);
  }
 catch (  IllegalStateException e) {
    logger.debug("<< reusing loadBalancer(%s)",name);
  }
  Set<String> instanceIds=ImmutableSet.copyOf(transform(nodes,new Function<NodeMetadata,String>(){
    @Override public String apply(    NodeMetadata from){
      return from.getProviderId();
    }
  }
));
  logger.debug(">> converging loadBalancer(%s) to instances(%s)",name,instanceIds);
  Set<String> registeredInstanceIds=client.getInstanceClientForRegion(region).registerInstancesWithLoadBalancer(instanceIds,name);
  Set<String> instancesToRemove=filter(registeredInstanceIds,not(in(instanceIds)));
  if (instancesToRemove.size() > 0) {
    logger.debug(">> deregistering instances(%s) from loadBalancer(%s)",instancesToRemove,name);
    client.getInstanceClientForRegion(region).deregisterInstancesFromLoadBalancer(instancesToRemove,name);
  }
  logger.debug("<< converged loadBalancer(%s) ",name);
  return converter.apply(new LoadBalancerInRegion(client.getLoadBalancerClientForRegion(region).get(name),region));
}
