{
  String message=options.getDir() != null ? String.format("clearing path %s/%s",containerName,options.getDir()) : String.format("clearing container %s",containerName);
  options=options.clone();
  if (options.isRecursive())   message=message + " recursively";
  Map<StorageMetadata,Exception> exceptions=Maps.newHashMap();
  PageSet<? extends StorageMetadata> listing;
  Iterable<? extends StorageMetadata> toDelete;
  int maxErrors=3;
  for (int i=0; i < maxErrors; ) {
    try {
      listing=connection.list(containerName,options).get();
    }
 catch (    ExecutionException ee) {
      ++i;
      if (i == maxErrors) {
        throw new BlobRuntimeException("list error",ee.getCause());
      }
      retryHandler.imposeBackoffExponentialDelay(i,message);
      continue;
    }
catch (    InterruptedException ie) {
      throw Throwables.propagate(ie);
    }
    toDelete=filterListing(listing,options);
    Map<StorageMetadata,Future<?>> responses=Maps.newHashMap();
    try {
      for (      final StorageMetadata md : toDelete) {
        String fullPath=parentIsFolder(options,md) ? options.getDir() + "/" + md.getName() : md.getName();
switch (md.getType()) {
case BLOB:
          responses.put(md,connection.removeBlob(containerName,fullPath));
        break;
case FOLDER:
      if (options.isRecursive() && !fullPath.equals(options.getDir())) {
        execute(containerName,options.clone().inDirectory(fullPath));
      }
    responses.put(md,connection.deleteDirectory(containerName,fullPath));
  break;
case RELATIVE_PATH:
if (options.isRecursive() && !fullPath.equals(options.getDir())) {
  execute(containerName,options.clone().inDirectory(fullPath));
}
responses.put(md,connection.deleteDirectory(containerName,md.getName()));
break;
case CONTAINER:
throw new IllegalArgumentException("Container type not supported");
}
}
}
  finally {
exceptions=awaitCompletion(responses,userExecutor,maxTime,logger,message);
}
if (!exceptions.isEmpty()) {
++i;
retryHandler.imposeBackoffExponentialDelay(i,message);
continue;
}
String marker=listing.getNextMarker();
if (marker == null) {
break;
}
options=options.afterMarker(marker);
}
if (!exceptions.isEmpty()) throw new BlobRuntimeException(String.format("error %s: %s",message,exceptions));
}
