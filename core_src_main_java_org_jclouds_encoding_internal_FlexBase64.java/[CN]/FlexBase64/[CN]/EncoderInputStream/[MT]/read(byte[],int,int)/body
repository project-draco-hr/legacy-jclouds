{
  byte[] buffer=this.buffer;
  byte[] overflow=this.overflow;
  int overflowPos=this.overflowPos;
  int overflowLimit=this.overflowLimit;
  boolean complete=this.complete;
  boolean wrap=encoder.wrap;
  int copy=0;
  if (overflowPos < overflowLimit) {
    copy=copyOverflow(b,off,len,overflow,overflowPos,overflowLimit);
    if (len <= copy || complete) {
      return copy;
    }
    len-=copy;
    off+=copy;
  }
 else   if (complete) {
    return -1;
  }
  for (; ; ) {
    byte[] source=buffer;
    int pos=this.pos;
    int limit=this.limit;
    boolean setPos=true;
    if (pos >= limit) {
      if (len > source.length) {
        int adjust=(len / 4 * 3) - 3;
        if (wrap) {
          adjust-=adjust / 76 * 2 + 2;
        }
        source=new byte[adjust];
        limit=input.read(source,0,adjust);
        pos=0;
        setPos=false;
      }
 else {
        limit=fill();
        pos=0;
      }
      if (limit <= 0) {
        this.complete=true;
        if (len < (wrap ? 4 : 2)) {
          overflowLimit=encoder.complete(overflow,0);
          this.overflowLimit=overflowLimit;
          int ret=copyOverflow(b,off,len,overflow,0,overflowLimit) + copy;
          return ret == 0 ? -1 : ret;
        }
        int ret=encoder.complete(b,off) - off + copy;
        return ret == 0 ? -1 : ret;
      }
    }
    if (len < (wrap ? 6 : 4)) {
      overflowLimit=encoder.encode(source,pos,limit,overflow,0,overflow.length);
      this.overflowLimit=overflowLimit;
      this.pos=encoder.getLastInputPosition();
      return copyOverflow(b,off,len,overflow,0,overflowLimit) + copy;
    }
    int read=encoder.encode(source,pos,limit,b,off,off + len) - off;
    if (setPos) {
      this.pos=encoder.getLastInputPosition();
    }
    if (read > 0) {
      return read + copy;
    }
  }
}
