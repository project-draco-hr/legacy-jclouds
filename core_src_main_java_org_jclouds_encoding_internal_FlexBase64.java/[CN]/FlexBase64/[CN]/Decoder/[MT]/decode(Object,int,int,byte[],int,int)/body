{
  if (target == null)   throw new IllegalStateException();
  int last=this.last;
  int state=this.state;
  int pos=sourcePos;
  int opos=targetPos;
  int limit=sourceLimit;
  int olimit=targetLimit;
  int b=0;
  while (limit > pos && olimit > opos) {
    b=nextByte(source,pos++,state,last,false);
    if (b == MARK) {
      last=MARK;
      if (pos >= limit) {
        break;
      }
      b=nextByte(source,pos++,state,last,false);
    }
    if (b == DONE) {
      last=state=0;
      break;
    }
    if (b == SKIP) {
      continue;
    }
    if (state == 0) {
      last=b << 2;
      state++;
      if (pos >= limit) {
        break;
      }
      b=nextByte(source,pos++,state,last,false);
      if ((b & 0xF000) != 0) {
        pos--;
        continue;
      }
    }
    if (state == 1) {
      target[opos++]=((byte)(last | (b >>> 4)));
      last=(b & 0x0F) << 4;
      state++;
      if (pos >= limit || opos >= olimit) {
        break;
      }
      b=nextByte(source,pos++,state,last,false);
      if ((b & 0xF000) != 0) {
        pos--;
        continue;
      }
    }
    if (state == 2) {
      target[opos++]=((byte)(last | (b >>> 2)));
      last=(b & 0x3) << 6;
      state++;
      if (pos >= limit || opos >= olimit) {
        break;
      }
      b=nextByte(source,pos++,state,last,false);
      if ((b & 0xF000) != 0) {
        pos--;
        continue;
      }
    }
    if (state == 3) {
      target[opos++]=((byte)(last | b));
      last=state=0;
    }
  }
  if (limit > pos) {
    pos=drain(source,pos,limit,b,state,last);
  }
  this.last=last;
  this.state=state;
  this.lastPos=pos;
  return opos;
}
