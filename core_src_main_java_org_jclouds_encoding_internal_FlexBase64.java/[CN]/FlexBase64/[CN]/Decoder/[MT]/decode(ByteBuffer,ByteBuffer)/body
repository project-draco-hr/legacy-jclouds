{
  if (target == null)   throw new IllegalStateException();
  int last=this.last;
  int state=this.state;
  int remaining=source.remaining();
  int targetRemaining=target.remaining();
  int b=0;
  while (remaining-- > 0 && targetRemaining > 0) {
    b=nextByte(source,state,last,false);
    if (b == MARK) {
      last=MARK;
      if (--remaining <= 0) {
        break;
      }
      b=nextByte(source,state,last,false);
    }
    if (b == DONE) {
      last=state=0;
      break;
    }
    if (b == SKIP) {
      continue;
    }
    if (state == 0) {
      last=b << 2;
      state++;
      if (remaining-- <= 0) {
        break;
      }
      b=nextByte(source,state,last,false);
      if ((b & 0xF000) != 0) {
        source.position(source.position() - 1);
        continue;
      }
    }
    if (state == 1) {
      target.put((byte)(last | (b >>> 4)));
      last=(b & 0x0F) << 4;
      state++;
      if (remaining-- <= 0 || --targetRemaining <= 0) {
        break;
      }
      b=nextByte(source,state,last,false);
      if ((b & 0xF000) != 0) {
        source.position(source.position() - 1);
        continue;
      }
    }
    if (state == 2) {
      target.put((byte)(last | (b >>> 2)));
      last=(b & 0x3) << 6;
      state++;
      if (remaining-- <= 0 || --targetRemaining <= 0) {
        break;
      }
      b=nextByte(source,state,last,false);
      if ((b & 0xF000) != 0) {
        source.position(source.position() - 1);
        continue;
      }
    }
    if (state == 3) {
      target.put((byte)(last | b));
      last=state=0;
      targetRemaining--;
    }
  }
  if (remaining > 0) {
    drain(source,b,state,last);
  }
  this.last=last;
  this.state=state;
  this.lastPos=source.position();
}
