{
  checkNotNull(loadBalancerName,"loadBalancerName");
  checkNotNull(protocol,"protocol");
  checkArgument(protocol.toUpperCase().equals("HTTP") || protocol.toUpperCase().equals("TCP"),"Acceptable values for protocol are HTTP or TCP");
  Map<Location,Set<String>> locationMap=Maps.newHashMap();
  for (  NodeMetadata node : Iterables.filter(context.getComputeService().listNodesDetailsMatching(NodePredicates.all()),Predicates.and(filter,Predicates.not(NodePredicates.TERMINATED)))) {
    Set<String> ids=locationMap.get(node.getLocation());
    if (ids == null)     ids=Sets.newHashSet();
    ids.add(node.getProviderId());
    locationMap.put(node.getLocation(),ids);
  }
  Set<InetAddress> dnsNames=Sets.newHashSet();
  for (  Location location : locationMap.keySet()) {
    logger.debug(">> creating load balancer (%s)",loadBalancerName);
    String dnsName=loadBalancerStrategy.execute(location,loadBalancerName,protocol,loadBalancerPort,instancePort,locationMap.get(location));
    for (int i=0; i < dnsRetries; i++) {
      try {
        dnsNames.add(InetAddress.getByName(dnsName));
      }
 catch (      UnknownHostException from) {
        backoffLimitedRetryHandler.imposeBackoffExponentialDelay(200L,2,i + 1,dnsRetries,String.format("%s/%s@%s:%d:%d connection error: %s",location,loadBalancerName,dnsName,loadBalancerPort,instancePort));
        continue;
      }
    }
    logger.debug("<< created load balancer (%s) DNS (%s)",loadBalancerName,dnsName);
  }
  return dnsNames;
}
